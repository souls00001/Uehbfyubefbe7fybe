
local default_color = Color3.fromRGB(150, 0, 0);
local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/judghementday2/paradox.co/refs/heads/main/UI.lua'))({
    cheatname = 'Paradox',
    gamename = 'Paradox',
    fileext = '.cfg',
    logo = '110294417718078',
    icon = '110294417718078',
    Accent = default_color
});
local Flags, Pointers = Library.Flags, Library.Pointers; getfenv(0)["Library"], getfenv(0)["Flags"], getfenv(0)["Pointers"] = Library, Flags, Pointers;

-- services
local Workspace     = cloneref(game:GetService"Workspace");
local run_service   = cloneref(game:GetService"RunService");
local rs            = cloneref(game:GetService"ReplicatedStorage");
local players       = cloneref(game:GetService"Players");
local uis           = cloneref(game:GetService"UserInputService");
local tween_service = cloneref(game:GetService"TweenService");
local stats         = cloneref(game:GetService"Stats");
local get_team      = cloneref(game:GetService"Teams");
local lighting      = cloneref(game:GetService"Lighting");

-- variables
local teams         = get_team:GetTeams();
local camera        = Workspace["CurrentCamera"];
local viewport_size = camera["ViewportSize"];
local local_player  = players["LocalPlayer"];
local lplayer_name  = local_player["Name"];
local local_char    = local_player.Character or local_player.CharacterAdded:Wait();
local get_mouse     = local_player:GetMouse();
local sky           = lighting:FindFirstChildOfClass("Sky") or cloneref(Instance.new("Sky", lighting));
local color_correct = lighting:FindFirstChildOfClass("ColorCorrectionEffect") or cloneref(Instance.new("ColorCorrectionEffect", lighting));
local fov_circle, snap_lines, skys = {}, {}, {};

-- game
local modules = rs:FindFirstChild("Modules");
local folder = Workspace:FindFirstChild("VFX") and Workspace.VFX:FindFirstChild("VMs")
local settings_module = modules:FindFirstChild("SettingsModule");
local settings_table = require(settings_module);
if (not settings_table) then
    return local_player:Kick("SettingsModule not found!");
end;
if (not folder) then
    return local_player:Kick("VMs not found!");
end;

-- lighting cache
local lighting_cache = {
    Brightness = game:GetService("Lighting").Brightness;
    ClockTime = game:GetService("Lighting").ClockTime;
    Ambient = game:GetService("Lighting").Ambient;
    OutdoorAmbient = game:GetService("Lighting").OutdoorAmbient;
    FogEnd = game:GetService("Lighting").FogEnd;
    FieldOfView = game:GetService("Workspace").CurrentCamera.FieldOfView;
    Density = game:GetService("Lighting"):FindFirstChild("Atmosphere").Density;
    Offset = game:GetService("Lighting"):FindFirstChild("Atmosphere").Offset;
    Glare = game:GetService("Lighting"):FindFirstChild("Atmosphere").Glare;
    Haze = game:GetService("Lighting"):FindFirstChild("Atmosphere").Haze;
};

-- skyboxes
local skyboxes = {
    ["Vaporwave"]      = {"1417494030"; "1417494146"; "1417494253"; "1417494402"; "1417494499"; "1417494643"};
    ["Redshift"]       = {"401664839"; "401664862"; "401664960"; "401664881"; "401664901"; "401664936"};
    ["Blaze"]          = {"150939022"; "150939038"; "150939047"; "150939056"; "150939063"; "150939082"};
    ["Among Us"]       = {"5752463190"; "5752463190"; "5752463190"; "5752463190"; "5752463190"; "5752463190"};
    ["Dark Night"]     = {"6285719338"; "6285721078"; "6285722964"; "6285724682"; "6285726335"; "6285730635"};
    ["Bright Pink"]    = {"271042516"; "271077243"; "271042556"; "271042310"; "271042467"; "271077958"};
};
for v in pairs(skyboxes) do table.insert(skys, v) end;

-- esp library
local highlight_player = nil;
local player_esp = {
    player_cache = {},
    drawing_cache = {},

    childadded_connections = {},
    childremoved_connections = {},
    functions = {},
};

-- targetting
local entry, closest_part;
local target_paradox = {
    target = {
        entry = nil,
        part = nil,
        distance = math.huge
    },
};
--
do -- handling
    local_player.CharacterAdded:Connect(function(character)
        local_char = character;
    end);
end;
--
do -- functions
    player_esp.functions.create_drawing = function(class, prop, ...)
        local inst = (typeof(class) == "string") and (Instance.new(class)) or (class);
        for property, val in pairs(prop) do
            inst[property] = val;
        end
        for _, t in {...} do
            table.insert(t, inst);
        end
        return inst;
    end;
    --
    player_esp.functions.get_boundings = function(model)
        local hrp = model:FindFirstChild("HumanoidRootPart");
        if hrp then
            local cframe, size = model:GetBoundingBox();
            size = Vector3.new(math.min(size.X, 2.5), math.min(size.Y, 6), math.min(size.Z, 5));
            return hrp.CFrame, size, hrp.Position;
        end;
        return nil;
    end;    
    -- 
    player_esp.functions.is_visible = function(character)
        if not character or character == local_player.Character then
            return false;
        end;
    
        local part = character.PrimaryPart
        if not part then return false end
    
        local raycast_params = RaycastParams.new()
        raycast_params.FilterType = Enum.RaycastFilterType.Blacklist
        local ignore_list = {local_player.Character, camera}
        
        if folder then
            for _, model in ipairs(folder:GetChildren()) do
                if model:IsA("Model") then
                    table.insert(ignore_list, model)
                end
            end
        end
    
        raycast_params.FilterDescendantsInstances = ignore_list
    
        local RaycastResult = Workspace:Raycast(camera.CFrame.p, (part.Position - camera.CFrame.p).Unit * 10000, raycast_params)
        return RaycastResult and RaycastResult.Instance and RaycastResult.Instance:IsDescendantOf(character)
    end;        
    -- 
    local function cache_character_parts(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return {} end

        if humanoid.RigType == Enum.HumanoidRigType.R6 then
            return { "Head", "Torso", "LeftLeg", "RightLeg", "LeftArm", "RightArm" };
        elseif humanoid.RigType == Enum.HumanoidRigType.R15 then
            return { "Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm", "LeftLeg", "RightLeg", "LeftFoot", "RightFoot" };
        end
        return {};
    end;
    --
    player_esp.functions.get_player = function()
        target_paradox.target.entry = nil
        target_paradox.target.part = nil
        target_paradox.target.distance = Flags["Enable FOV"] and Flags["FOV Radius"] / math.tan(math.rad(camera.FieldOfView / 2)) or math.huge
    
        local mouse_position, cam_position = uis:GetMouseLocation(), camera.CFrame.Position
        local closest_entry, closest_part = nil, nil
        local part_cache = {}
        local ignore_team_check = #teams == 0 or (#teams == 1 and Flags["Friendly Check"])
    
        for _, player in ipairs(players:GetPlayers()) do
            if player == local_player then continue end;
            local character = player.Character;
            if character and character:FindFirstChild("Humanoid") then
                if not Flags["Friendly Check"] or ignore_team_check or player ~= local_player and (not player.Team or not local_player.Team or player.Team ~= local_player.Team) then
                else
                    continue;
                end;
    
                if (not part_cache[player]) then
                    part_cache[player] = cache_character_parts(character);
                end;
    
                local bones_to_check = Flags["Aimbot Bone"] == "Closest Bone" and part_cache[player] or { Flags["Aimbot Bone"] }
                for _, part_name in ipairs(bones_to_check) do
                    local part = character:FindFirstChild(part_name);
                    if part then
                        local screen_pos, on_screen = camera:WorldToViewportPoint(part.Position)
                        if on_screen then
                            local mouse_distance = (Vector2.new(screen_pos.X, screen_pos.Y) - Vector2.new(mouse_position.X, mouse_position.Y)).Magnitude
                            local distance_to_target = (part.Position - cam_position).Magnitude;
                            local is_part_visible = not Flags["Visible Check"] or (player ~= local_player and player_esp.functions.is_visible(character))
                            if distance_to_target <= (Flags["Aimbot Max Distance"] or math.huge) and is_part_visible then
                                if mouse_distance < target_paradox.target.distance or (mouse_distance == target_paradox.target.distance and distance_to_target < (target_paradox.target.part and (target_paradox.target.part.Position - cam_position).Magnitude or math.huge)) then
                                    closest_entry = player
                                    closest_part = part
                                    target_paradox.target.distance = mouse_distance
                                end;
                            end;
                        end;
                    end;
                end;
            end;
        end;
    
        return closest_entry, closest_part;
    end;     
    --
    player_esp.functions.get_tool = function(Character)
        for _, value in pairs(Character:GetChildren()) do
            if value.Name ~= "HolsterModel" and value:IsA("Model") and value.Name ~= "Hair" and (value:FindFirstChild("Detail") or value:FindFirstChild("Main") or value:FindFirstChild("Handle") or value:FindFirstChild("Attachments") or value:FindFirstChild("ArrowAttach") or value:FindFirstChild("Attach")) and value.PrimaryPart then
                return value.Name;
            end;
        end;
        return "None";
    end;  
end;
--
do -- player esp
    player_esp.update_player_ESP = function(player)
        if (player.Name == lplayer_name) then
            return;
        end;
        --
        local esp_holder = player_esp.functions.create_drawing("ScreenGui", { Parent = cloneref(gethui()), Name = "esp_holder" });
        local drawings = {
            -- text
            name = player_esp.functions.create_drawing("TextLabel", {
                Visible = false,
                Parent = esp_holder,
                BackgroundTransparency = 1,
                TextStrokeTransparency = 0,
                TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
                FontFace = Font.new([[rbxassetid://12187365977]], Enum.FontWeight.SemiBold, Enum.FontStyle.Normal),
                TextSize = 11,
                TextXAlignment = Enum.TextXAlignment.Center
            }),
            distance = player_esp.functions.create_drawing("TextLabel", {
                Visible = false,
                Parent = esp_holder,
                BackgroundTransparency = 1,
                TextStrokeTransparency = 0,
                TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
                FontFace = Font.new([[rbxassetid://12187365977]], Enum.FontWeight.SemiBold, Enum.FontStyle.Normal),
                TextSize = 11,
                TextXAlignment = Enum.TextXAlignment.Left,
                TextYAlignment = Enum.TextYAlignment.Top
            }),
            weapon = player_esp.functions.create_drawing("TextLabel", {
                Visible = false,
                Parent = esp_holder,
                BackgroundTransparency = 1,
                TextStrokeTransparency = 0,
                TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
                FontFace = Font.new([[rbxassetid://12187365977]], Enum.FontWeight.SemiBold, Enum.FontStyle.Normal),
                TextSize = 11,
                TextXAlignment = Enum.TextXAlignment.Center
            }),

            -- box
            box = player_esp.functions.create_drawing("Frame", {
                Visible = false,
                Parent = esp_holder,
                BackgroundTransparency = 1,
                BackgroundColor3 = Color3.new(1, 1, 1),
                ZIndex = -999
            }),
            box2 = player_esp.functions.create_drawing("Frame", {
                Visible = false,
                Parent = esp_holder,
                BackgroundTransparency = 1,
                BackgroundColor3 = Color3.new(1, 1, 1),
                ZIndex = 999
            }),          
            Outline = player_esp.functions.create_drawing("UIStroke", {
                Color = Color3.fromRGB(0, 0, 0),
                Thickness = 3,
                Transparency = 0,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Enabled = true
            }),
            Outline2 = player_esp.functions.create_drawing("UIStroke", {
                Thickness = 1,
                Enabled = true,
                LineJoinMode = Enum.LineJoinMode.Miter
            }),

            -- healthbar
            BehindHealthbar = player_esp.functions.create_drawing("Frame", {
                Visible = false,
                Parent = esp_holder,
                ZIndex = -1,
                BackgroundColor3 = Color3.fromRGB(0, 0, 0),
                BackgroundTransparency = 0,
                BorderSizePixel = 1,
                BorderColor3 = Color3.fromRGB(0, 0, 0)
            }),
            Healthbar = player_esp.functions.create_drawing("Frame", {
                Visible = false,
                Parent = esp_holder,
                BackgroundColor3 = Color3.fromRGB(255, 255, 255),
                BackgroundTransparency = 0,
                BorderSizePixel = 0
            }),
            HealthText = player_esp.functions.create_drawing("TextLabel", { 
                Visible = false,
                Parent = esp_holder, 
                TextXAlignment = Enum.TextXAlignment.Right, 
                FontFace = Font.new([[rbxassetid://12187365977]], Enum.FontWeight.SemiBold, Enum.FontStyle.Normal), 
                TextSize = 11, 
                BackgroundTransparency = 1, 
                TextStrokeTransparency = 0, 
                ZIndex = 999, 
                TextStrokeColor3 = Color3.new(0, 0, 0) 
            }),

            -- text strokes
            name_stroke = player_esp.functions.create_drawing("UIStroke", {
                Thickness = 1,
                LineJoinMode = Enum.LineJoinMode.Round,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Color = Color3.fromRGB(0, 0, 0)
            }),
            distance_stroke = player_esp.functions.create_drawing("UIStroke", {
                Thickness = 1,
                LineJoinMode = Enum.LineJoinMode.Round,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Color = Color3.fromRGB(0, 0, 0)
            }),
            weapon_stroke = player_esp.functions.create_drawing("UIStroke", {
                Thickness = 1,
                LineJoinMode = Enum.LineJoinMode.Round,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Color = Color3.fromRGB(0, 0, 0)
            }),
        };      
        --
        local chams;
        do -- create chams
            chams = Instance.new("Highlight", player.Character);
            chams.Enabled = false;
        end   
        -- 
        local linepos = function(frame, from, to, thickness, plrpos)
            local c = (from + to) / 2
            local o = to - from + Vector2.new(0, 1)
            local d = (plrpos - camera.CFrame.p).Magnitude
            frame.Position = UDim2.new(0, c.X, 0, c.Y)
            frame.Rotation = math.atan2(o.Y, o.X) * 180 / math.pi
        
            frame.Size = UDim2.new(0, o.Magnitude, 0, thickness)
        end;
        --
        local function createline()
            local frame = Instance.new("Frame", esp_holder)
            frame.AnchorPoint = Vector2.new(0.5, 0.5)
            frame.ZIndex = -999
            frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
            frame.BorderSizePixel = 0
            frame.Visible = false
            return frame
        end;         
        -- 
        local viewangle_parts = {
            Head = createline();
        };
        local parts = {
            UpperTorso_LowerTorso 		= createline(); UpperTorso_LeftUpperArm 	= createline(); UpperTorso_RightUpperArm 	= createline();
            LeftUpperArm_LeftLowerArm 	= createline(); LeftLowerArm_LeftHand 		= createline(); LeftUpperLeg_LeftLowerLeg 	= createline(); LeftLowerLeg_LeftFoot 		= createline();
            RightUpperArm_RightLowerArm = createline(); RightLowerArm_RightHand 	= createline(); RightUpperLeg_RightLowerLeg = createline(); RightLowerLeg_RightFoot 	= createline();
            LowerTorso_LeftUpperLeg 	= createline(); LowerTorso_RightUpperLeg 	= createline();
        };
        --
        drawings.Outline.Parent = drawings.box;
        drawings.Outline2.Parent = drawings.box2;
        drawings.name_stroke.Parent = drawings.name;
        drawings.distance_stroke.Parent = drawings.distance;
        drawings.weapon_stroke.Parent = drawings.weapon;
        --
        table.insert(player_esp.drawing_cache, {
            name = drawings.name,
            distance = drawings.distance,
            weapon = drawings.weapon,
            box = drawings.box,
            box2 = drawings.box2,
            healthbar = drawings.BehindHealthbar,
            healthbar2 = drawings.Healthbar,
            esp_holder = esp_holder,
            update_conn = nil,
            player = player
        });
        --
        do -- update esp
            local died_check = false;
            local tween = {
                health_start = 0,
                health_transition_start = 0,
                health_transition_old = 0,
                current_health = 0
            };
            --
            player_esp.update_esp = LPH_NO_VIRTUALIZE(function()
                local character = player.Character;
                local humanoid = character:FindFirstChild("Humanoid");
                local cframe, size, position = player_esp.functions.get_boundings(character);

                do -- ESP
                    if (character and humanoid) then
                        local max_distance;
                        if position then
                            max_distance = (position - camera.CFrame.Position).Magnitude
                        end                        
                        if max_distance and max_distance < Flags["Max ESP Distance"] then
                            if (not Flags["Enable TeamCheck"] or (player ~= local_player and (local_player.Team ~= player.Team or not local_player.Team or not player.Team))) then
                                local pos, on_screen = camera:WorldToScreenPoint(position);
                                local height = math.tan(math.rad(camera.FieldOfView / 2)) * 2 * pos.Z;
                                local scale = Vector2.new((viewport_size.Y / height) * size.X, (viewport_size.Y / height) * size.Y);

                                do -- names
                                    if (on_screen) and Flags["Enable Names"] then
                                        drawings.name.Visible = true;
                                        drawings.name.Text = Flags["Display Name"] and player.DisplayName or player.Name;
                                        drawings.name.TextColor3 = drawings.name.TextColor3:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Names Accent"], 0.02);
                                        drawings.name.Position = UDim2.new(0, pos.X, 0, pos.Y - scale.Y / 2 - 6);
                                    else
                                        drawings.name.Visible = false;
                                    end;
                                end;
                                
                                do -- chams
                                    if (on_screen) and Flags["Enable Chams"] then
                                        chams.Enabled = true;
                                        chams.DepthMode = Flags["Chams Visible Check"] == "Always Visible" and Enum.HighlightDepthMode["AlwaysOnTop"] or Enum.HighlightDepthMode["Occluded"];
                                        chams.FillTransparency = Flags["Chams Opacity"] / 100;
                                        chams.OutlineTransparency = Flags["Chams Opacity"] / 100;
                                        chams.FillColor = chams.FillColor:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Chams Accent"], 0.02);
                                        chams.OutlineColor = chams.OutlineColor:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Chams Accent"], 0.02);
                                    else
                                        chams.Enabled = false;
                                    end;
                                end;

                                do -- view angle
                                    if (on_screen) and Flags["Enable Viewangle"] and character and character:FindFirstChild("Head") then
                                        local head_pos = camera:WorldToScreenPoint(character.Head.Position);
                                        local look_dir = character.Head.CFrame.LookVector;
                                        local line_length = Flags["Viewangle Length"];
                                        local end_pos = character.Head.Position + (look_dir * line_length);
                                        local end_point = camera:WorldToScreenPoint(end_pos);
                                    
                                        local positions = {
                                            Head = Vector2.new(head_pos.X, head_pos.Y),
                                            Look = Vector2.new(end_point.X, end_point.Y),
                                        };
                                    
                                        for _, part in pairs(viewangle_parts) do
                                            part.BackgroundColor3 = part.BackgroundColor3:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Viewangle Accent"], 0.02)
                                        end;   
                                    
                                        if (Flags["Outline Skeletons/ViewAngle"]) then
                                            for _, part in pairs(viewangle_parts) do
                                                part.BorderSizePixel = 1;
                                            end;
                                        else
                                            for _, part in pairs(viewangle_parts) do
                                                part.BorderSizePixel = 0;
                                            end;
                                        end;
                                    
                                        if (viewangle_parts.Head) then
                                            linepos(viewangle_parts.Head, positions.Head, positions.Look, 1, character.Head.Position);
                                            for _, part in pairs(viewangle_parts) do
                                                part.Visible = true;
                                            end;
                                        end;
                                    else
                                        for _, part in pairs(viewangle_parts) do
                                            part.Visible = false;
                                        end;
                                    end;                                                                                                                                                                                                                                                                                      
                                end;

                                do -- skeletons
                                    if (on_screen) and Flags["Enable Skeletons"] and character and character:FindFirstChild("UpperTorso") and character:FindFirstChild("HumanoidRootPart") then
                                        local get_parts = {
                                            "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
                                            "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
                                            "RightUpperLeg", "RightLowerLeg", "RightFoot"
                                        };
                                    
                                        for _, v in pairs(get_parts) do
                                            if not character:FindFirstChild(v) then
                                                return;
                                            end
                                        end
                                    
                                        local positions = {}
                                        for _, v in pairs(get_parts) do
                                            local world_pos = character[v].Position;
                                            local screenPos, onScreen = camera:WorldToScreenPoint(world_pos);
                                    
                                            if onScreen and screenPos.Z > 0 then
                                                positions[v] = Vector2.new(screenPos.X, screenPos.Y);
                                            else
                                                return;
                                            end;
                                        end;

                                        for _, part in pairs(parts) do
                                            part.BackgroundColor3 = part.BackgroundColor3:Lerp(Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"] or Flags["Skeletons Accent"], 0.02);
                                        end;

                                        local border_size = Flags["Outline Skeletons/ViewAngle"] and 1 or 0;
                                        for _, part in pairs(parts) do
                                            part.BorderSizePixel = border_size;
                                        end;
                                    
                                        local root = character.HumanoidRootPart.Position
                                        linepos(parts.UpperTorso_LowerTorso, positions.UpperTorso, positions.LowerTorso, Flags["Skeleton Thickness"], root);
                                        linepos(parts.UpperTorso_LeftUpperArm, positions.UpperTorso, positions.LeftUpperArm, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LeftUpperArm_LeftLowerArm, positions.LeftUpperArm, positions.LeftLowerArm, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LeftLowerArm_LeftHand, positions.LeftLowerArm, positions.LeftHand, Flags["Skeleton Thickness"], root);
                                        linepos(parts.UpperTorso_RightUpperArm, positions.UpperTorso, positions.RightUpperArm, Flags["Skeleton Thickness"], root);
                                        linepos(parts.RightUpperArm_RightLowerArm, positions.RightUpperArm, positions.RightLowerArm, Flags["Skeleton Thickness"], root);
                                        linepos(parts.RightLowerArm_RightHand, positions.RightLowerArm, positions.RightHand, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LowerTorso_LeftUpperLeg, positions.LowerTorso, positions.LeftUpperLeg, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LeftUpperLeg_LeftLowerLeg, positions.LeftUpperLeg, positions.LeftLowerLeg, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LeftLowerLeg_LeftFoot, positions.LeftLowerLeg, positions.LeftFoot, Flags["Skeleton Thickness"], root);
                                        linepos(parts.LowerTorso_RightUpperLeg, positions.LowerTorso, positions.RightUpperLeg, Flags["Skeleton Thickness"], root);
                                        linepos(parts.RightUpperLeg_RightLowerLeg, positions.RightUpperLeg, positions.RightLowerLeg, Flags["Skeleton Thickness"], root);
                                        linepos(parts.RightLowerLeg_RightFoot, positions.RightLowerLeg, positions.RightFoot, Flags["Skeleton Thickness"], root);

                                        for _, part in pairs(parts) do
                                            part.Visible = true;
                                        end;
                                    else
                                        for _, part in pairs(parts) do
                                            part.Visible = false;
                                        end;
                                    end;                           
                                end;

                                do -- boxes
                                    if (on_screen) and Flags["Enable Boxes"] then
                                        drawings.box.Size = UDim2.new(0, scale.X - 1, 0, scale.Y - 1);
                                        drawings.box2.Size = UDim2.new(0, scale.X + 1, 0, scale.Y + 1);

                                        drawings.box.Position = UDim2.new(0, pos.X - (scale.X / 2), 0, pos.Y - (scale.Y / 2) + 3);
                                        drawings.box2.Position = UDim2.new(0, pos.X - (scale.X / 2) - 1, 0, pos.Y - (scale.Y / 2) + 2);

                                        if (Flags["Boxes Filled"]) then
                                            drawings.box.BackgroundTransparency = Flags["Boxes Filled Opacity"] / 100;
                                            drawings.box.BackgroundColor3 = Flags["Filled Boxes Accent"];
                                        else
                                            drawings.box.BackgroundTransparency = 1;
                                        end;

                                        drawings.box.Visible = true;
                                        drawings.box2.Visible = true;
                                        drawings.Outline2.Color = drawings.Outline2.Color:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Boxes Accent"], 0.02);
                                    else
                                        drawings.box.Visible = false;
                                        drawings.box2.Visible = false;
                                    end;
                                end;

                                do -- distances
                                    if (on_screen) and Flags["Enable Distance"] then
                                        local box_side = pos.X + (scale.X / 2);
                                        local box_top = pos.Y - (scale.Y / 2);
                                        drawings.distance.Position = UDim2.new(0, box_side + 3, 0, box_top - 1);
                                        drawings.distance.Visible = true;
                                        drawings.distance.TextColor3 = drawings.distance.TextColor3:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Distance Accent"], 0.02);
                                        drawings.distance.Text = string.format("%ds", math.floor(max_distance));
                                    else
                                        drawings.distance.Visible = false;
                                    end;
                                end;

                                do -- weapon
                                    if (on_screen) and Flags["Enable Weapon"] then
                                        drawings.weapon.Visible = true;
                                        drawings.weapon.Position = UDim2.new(0, pos.X - 2, 0, pos.Y + scale.Y / 2 + 11);
                                        drawings.weapon.TextColor3 = drawings.weapon.TextColor3:Lerp((Flags["Highlight ESP"] and highlight_player == player and Flags["Highlight Accent"]) and Flags["Highlight Accent"] or Flags["Weapon Accent"], 0.02);
                                        drawings.weapon.Text = player_esp.functions.get_tool(character);
                                    else
                                        drawings.weapon.Visible = false;
                                    end;
                                end;

                                do -- healthbar
                                    if (on_screen) and Flags["Enable Healthbar"] and humanoid and humanoid.Health then
                                        local health, max_health = math.floor(humanoid.Health), humanoid.MaxHealth
                                        local health_color = Color3.new(1, 0, 0):lerp(Color3.new(0.7, 0.8, 0), math.clamp(health / max_health, 0, 1))
                                        health_color = health_color:lerp(Color3.new(0, 1, 0), math.clamp((health / max_health - 0.5) * 2, 0, 1))

                                        do -- healthbar animation
                                            tween.health_start = tween.health_start or 0
                                            tween.health_transition_start = tween.health_transition_start or health
                                            tween.health_transition_old = tween.health_transition_old or health
                                            tween.current_health = tween.current_health or health

                                            if health ~= tween.health_transition_start then
                                                tween.health_transition_old, tween.health_transition_start, tween.health_start = tween.current_health, health, tick()
                                            end;
                                        end;

                                        local progress = math.clamp((tick() - tween.health_start) / 0.2, 0, 1)
                                        tween.current_health = tween.health_transition_old + (tween.health_transition_start - tween.health_transition_old) * progress

                                        if progress >= 1 then
                                            tween.current_health, tween.health_transition_old, tween.health_transition_start, tween.health_start = health, health, health, 0
                                        end;

                                        if Flags["Enable Healthtext"] then
                                            drawings.HealthText.TextColor3 = health_color
                                            drawings.HealthText.Text, drawings.HealthText.Visible = tostring(math.floor(tween.current_health)), true;
                                        else
                                            drawings.HealthText.Visible = false;
                                        end;

                                        drawings.Healthbar.Visible = true
                                        drawings.BehindHealthbar.Visible = true

                                        local bar_width = 1
                                        local bar_height_adjust = 3
                                        local target_height = scale.Y * (tween.current_health / max_health) + bar_height_adjust
        
                                        local bar_offset = 5 + math.max(0, bar_width)
                                        drawings.Healthbar.Position = UDim2.new(0, pos.X - scale.X / 2 - bar_offset, 0, pos.Y - scale.Y / 2 + scale.Y * (1 - tween.current_health / max_health) + 1)
                                        drawings.BehindHealthbar.Position = UDim2.new(0, pos.X - scale.X / 2 - bar_offset, 0, pos.Y - scale.Y / 2 + 1)
                                        drawings.Healthbar.Size = UDim2.new(0, bar_width, 0, target_height)
                                        drawings.BehindHealthbar.Size = UDim2.new(0, bar_width, 0, scale.Y + bar_height_adjust)
                                        local target_text_pos = UDim2.new(0, pos.X - scale.X / 2 - 9, 0, pos.Y - scale.Y / 2 + scale.Y * (1 - tween.current_health / max_health) + 5) or UDim2.new(0, pos.X - scale.X / 2 + scale.X * (tween.current_health / max_health), 0, pos.Y + scale.Y / 2 + 5)
                                        drawings.HealthText.Position = drawings.HealthText.Position:Lerp(target_text_pos, progress)
                                        drawings.Healthbar.BackgroundColor3 = health_color;
                                    else
                                        drawings.Healthbar.Visible = false;
                                        drawings.BehindHealthbar.Visible = false;
                                        drawings.HealthText.Visible = false;
                                    end;
                                    --
                                end;
                            else
                                for _, v in ipairs({"name", "box", "box2", "distance", "weapon", "BehindHealthbar", "HealthText", "Healthbar"}) do
                                    drawings[v].Visible = false;
                                end;
                                for _, part in pairs(parts) do
                                    part.Visible = false;
                                end;
                                for _, part in pairs(viewangle_parts) do
                                    part.Visible = false;
                                end;
                                chams.Enabled = false;
                            end
                        else
                            for _, v in ipairs({"name", "box", "box2", "distance", "weapon", "BehindHealthbar", "HealthText", "Healthbar"}) do
                                drawings[v].Visible = false;
                            end;
                            for _, part in pairs(parts) do
                                part.Visible = false;
                            end;
                            for _, part in pairs(viewangle_parts) do
                                part.Visible = false;
                            end;
                            chams.Enabled = false;
                        end;
                    else
                        for _, v in ipairs({"name", "box", "box2", "distance", "weapon", "BehindHealthbar", "HealthText", "Healthbar"}) do
                            drawings[v].Visible = false;
                        end;
                        for _, part in pairs(parts) do
                            part.Visible = false;
                        end;
                        for _, part in pairs(viewangle_parts) do
                            part.Visible = false;
                        end;
                        chams.Enabled = false;
                    end;
                end;
            end);
        end;

        local cache = player_esp.drawing_cache[#player_esp.drawing_cache];
        cache.update_conn = run_service["RenderStepped"]:Connect((player_esp.update_esp));
    end;
    --
    player_esp.remove_player_ESP = function(player)
        for _, cache in ipairs(player_esp.drawing_cache) do
            if cache.player == player then
                if cache.update_conn then
                    cache.update_conn:Disconnect();
                end;
                cache.esp_holder:Destroy();
                table.remove(player_esp.drawing_cache, _);
                break;
            end;
        end;
    end;
    --
    player_esp.on_player_added = function(player)
        local connections = {};
        connections.character_added = player.CharacterAdded:Connect(function()
            player_esp.update_player_ESP(player);
        end);
        connections.character_removing = player.CharacterRemoving:Connect(function()
            player_esp.remove_player_ESP(player);
        end);

        player_esp.connection_cache = player_esp.connection_cache or {}
        table.insert(player_esp.connection_cache, { player = player, connections = connections });

        if player.Character then
            player_esp.update_player_ESP(player);
        end;
    end;
    --
    player_esp.handle_existing_players = function()
        local player_list = players:GetPlayers();
        for i = 1, #player_list do
            local player = player_list[i];
            if player.Name ~= lplayer_name then
                player_esp.on_player_added(player);
            end;
        end;
    end;
    --
    players.PlayerAdded:Connect(player_esp.on_player_added)
    players.PlayerRemoving:Connect(function(player)
        player_esp.remove_player_ESP(player);
        for i, cache in ipairs(player_esp.connection_cache) do
            if cache.player == player then
                for _, conn in pairs(cache.connections) do
                    conn:Disconnect();
                end;
                table.remove(player_esp.connection_cache, i);
                break;
            end;
        end;
    end);
    player_esp.handle_existing_players();
end;
--
local ui = {
    window = nil,
    sections = {},
    tabs = {}
};
ui.window = Library:New({Size = UDim2.new(0, 600, 0, 500)});
--
getgenv().silent = false;
getgenv().silent_key = false;
getgenv().silent_hitchance = 100;
do -- menu
    do -- combat
        ui.window:Seperator({Name = 'Combat'});
        ui.tabs['legit'] = ui.window:Page({
            Name = 'Legit',
            Icon = 'http://www.roblox.com/asset/?id=6023426921'
        });
        do
            ui.sections['legit_main'] = ui.tabs['legit']:Section({Name = 'Main', Side = 'Left', Size = 427});
            ui.sections['legit_main']:Toggle({Name = 'Aimbot', Flag = 'Enable Aimbot'});
            ui.sections['legit_main']:Toggle({Name = 'Silent Aim', Flag = 'Enable Silent Aim', Callback = function(state) getgenv().silent = state; end});
            ui.sections['legit_main']:Toggle({Name = 'Prediction', Flag = 'Enable Prediction'});
            ui.sections['legit_main']:Keybind({Flag = 'Aimbot Keybind', Name = 'Aimbot Keybind', Default = Enum.UserInputType.MouseButton2, Mode = 'Hold'});
            ui.sections['legit_main']:Keybind({Flag = 'Silent Aim Keybind', Name = 'Silent Aim Keybind', Default = Enum.UserInputType.MouseButton1, Mode = 'Hold', Callback = function(state) getgenv().silent_key = state; end});
            ui.sections['legit_main']:Slider({Name = 'Aimbot Speed', Flag = 'Aimbot Speed', Default = 0.5, Minimum = 0.05, Maximum = 1, Decimals = 0.01, Ending = ''});
            ui.sections['legit_main']:Slider({Name = 'Hitchance', Flag = 'Hitchance', Default = 100, Minimum = 1, Maximum = 100, Decimals = 1, Ending = '%', Callback = function(state) getgenv().silent_hitchance = state; end});
            ui.sections['legit_main']:Slider({Name = 'Max Distance', Flag = 'Aimbot Max Distance', Default = 500, Minimum = 100, Maximum = 2500, Decimals = 1, Ending = 's'});
            ui.sections['legit_main']:List({Name = 'Aimbone', Flag = 'Aimbot Bone', Options = {'Head', 'UpperTorso', 'LowerTorso', "Closest Bone"}, Default = 'Head'});
        end;
        do
            ui.sections['select_options'] = ui.tabs['legit']:Section({Name = 'Select', Side = 'Right', Size = 427});
            ui.sections['select_options']:Toggle({Name = 'Team Check', Flag = 'Friendly Check'});
            ui.sections['select_options']:Toggle({Name = 'Visible Check', Flag = 'Visible Check'});
            ui.sections['select_options']:Toggle({Name = 'FOV Circle', Flag = 'Enable FOV'});
            ui.sections['select_options']:Colorpicker({Name = 'FOV Color', Flag = 'FOV Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['select_options']:Slider({Name = 'FOV Radius', Flag = 'FOV Radius', Default = 120, Minimum = 30, Maximum = 750, Decimals = 1, Ending = 'px'});
            ui.sections['select_options']:Toggle({Name = 'Snaplines', Flag = 'Enable Snaplines'});
            ui.sections['select_options']:Colorpicker({Name = 'Snaplines Color', Flag = 'Snaplines Accent', Default = Color3.fromRGB(255, 255, 255)});
        end;
        --
        ui.tabs['rage'] = ui.window:Page({
            Name = 'Rage',
            'http://www.roblox.com/asset/?id=6023426921'
        });
        do
            ui.sections['rage_main'] = ui.tabs['rage']:Section({Name = 'Player', Side = 'Left', Size = 167});
            ui.sections['rage_main']:Toggle({Name = 'Always Grounded', Flag = 'Always Grounded'});
            ui.sections['rage_main']:Toggle({Name = 'Always Sprint', Flag = 'Always Sprint'});
            ui.sections['rage_main']:Toggle({Name = 'Spiderclimb', Flag = 'Spiderclimb'});
            ui.sections['rage_main']:Keybind({Flag = 'Spiderclimb Keybind', Name = 'Spiderclimb Keybind', Default = Enum.KeyCode.Space, Mode = 'Hold'});
            ui.sections['rage_main']:Slider({Name = 'Spiderclimb Speed', Flag = 'Spiderclimb Speed', Default = 0.75, Minimum = 0.5, Maximum = 1.5, Decimals = 0.01, Ending = ''});
        end;
        do
            ui.sections['hit'] = ui.tabs['rage']:Section({Name = 'Hit', Side = 'Left', Size = 187});
            ui.sections['hit']:Toggle({Name = 'Bullet Tracers', Flag = 'Bullet Tracers'});
            ui.sections['hit']:Colorpicker({Name = 'Tracer Color', Flag = 'Tracer Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['hit']:Toggle({Name = 'Hitmarkers', Flag = 'Hitmarkers'});
            ui.sections['hit']:Colorpicker({Name = 'Hitmarker Color', Flag = 'Hitmarker Accent', Default = Color3.fromRGB(255, 255, 255)});
        end;
        do
            ui.sections['camera'] = ui.tabs['rage']:Section({Name = 'Camera', Side = 'Right', Size = 187});
            ui.sections['camera']:Toggle({Name = 'FOV', Flag = 'FOV'});
            ui.sections['camera']:Slider({Name = 'FOV Ammount', Flag = 'FOV Ammount', Default = 70, Minimum = 30, Maximum = 120, Decimals = 1, Ending = 'x'});
            ui.sections['camera']:Toggle({Name = 'Zoom', Flag = 'Zoom'});
            ui.sections['camera']:Keybind({Flag = 'Zoom Keybind', Name = 'Zoom Keybind', Mode = 'Hold'});
            ui.sections['camera']:Slider({Name = 'Zoom Ammount', Flag = 'Zoom Ammount', Default = 30, Minimum = 5, Maximum = 70, Decimals = 1, Ending = 'x'});
        end;
        do
            local gun_mods = {
                old_recoil1 = nil,
                old_recoil2 = nil,
                old_spread = {};
                old_firerates = {};
                old_auto = {};
                old_bullet_speeds = {};
                old_vm_mults = {};
            };
            ui.sections['rage_weaponmods'] = ui.tabs['rage']:Section({Name = 'Weapon Mods', Side = 'Right', Size = 220})
            ui.sections['rage_weaponmods']:Toggle({ Name = "Force Auto", Flag = "Force Auto", Default = false, Callback = function(state)
                if (state) then
                    for _, tbl in getgc(true) do
                        if type(tbl) ~= "table" then
                            continue;
                        end;
    
                        local weapon_auto = rawget(tbl, "Auto");
                        if weapon_auto ~= nil then
                            if not gun_mods.old_auto[tbl] then
                                gun_mods.old_auto[tbl] = weapon_auto;
                            end;
    
                            tbl.Auto = true;
                        end
                    end
                else
                    for tbl, v in gun_mods.old_auto do tbl["Auto"] = v end;
                end
            end});
            ui.sections['rage_weaponmods']:Toggle({Name = 'No Recoil', Flag = 'No Recoil', Callback = function(state)
                for _, tbl in getgc(true) do
                    if type(tbl) ~= "table" then continue end
        
                    local recoil_start = rawget(tbl, "RecoilStart")
                    local recoil_finish = rawget(tbl, "RecoilFinish")
        
                    if recoil_start and recoil_finish and type(recoil_start) == "function" and type(recoil_finish) == "function" then
                        if state then
                            gun_mods.old_recoil1 = gun_mods.old_recoil1 or recoil_start
                            gun_mods.old_recoil2 = gun_mods.old_recoil2 or recoil_finish
        
                            rawset(tbl, "RecoilStart", function() return 0, 0 end)
                            rawset(tbl, "RecoilFinish", function() return 0, 0 end)
                        else
                            if gun_mods.old_recoil1 then rawset(tbl, "RecoilStart", gun_mods.old_recoil1) end
                            if gun_mods.old_recoil2 then rawset(tbl, "RecoilFinish", gun_mods.old_recoil2) end
        
                            gun_mods.old_recoil1 = nil
                            gun_mods.old_recoil2 = nil
                        end
                    end
                end
            end});
            ui.sections['rage_weaponmods']:Toggle({ Name = 'No Spread', Flag = 'No Spread', Callback = function(state)
                for _, tbl in getgc(true) do
                    if type(tbl) ~= "table" then continue end
                    
                    local spread_table = rawget(tbl, "Spread")
                    if spread_table and typeof(spread_table) == "table" then
                        for _, spread_stuff in spread_table do
                            for i, v in spread_stuff do
                                if type(v) == "number" then
                                    gun_mods.old_spread[spread_stuff] = gun_mods.old_spread[spread_stuff] or {};
                                    gun_mods.old_spread[spread_stuff][i] = gun_mods.old_spread[spread_stuff][i] or v;
                                    spread_stuff[i] = state and 0 or gun_mods.old_spread[spread_stuff][i];
                                end
                            end
                        end
                    end
                end
            end});   
            ui.sections['rage_weaponmods']:Toggle({Name = 'No Sway', Flag = 'No Sway', Callback = function(state)
                if (state) then
                    for _, tbl in getgc(true) do
                        if type(tbl) ~= "table" then
                            continue;
                        end;
    
                        local vm_movement_mults = rawget(tbl, "VMMovementMults");
                        if vm_movement_mults then
                            for i, v in vm_movement_mults do
                                if not gun_mods.old_vm_mults[vm_movement_mults] then
                                    gun_mods.old_vm_mults[vm_movement_mults] = {};
                                end;
    
                                if not gun_mods.old_vm_mults[vm_movement_mults][i] then
                                    gun_mods.old_vm_mults[vm_movement_mults][i] = v;
                                end;
    
                                vm_movement_mults[i] = 0;
                            end
                        end
                    end
                else
                    for tbl, values in gun_mods.old_vm_mults do
                        for i, v in values do
                            tbl[i] = v;
                        end;
                    end;
                end;
            end});
            --
            local fast_fire_callback = function()
                local value = Library.Flags["Enable RPM"];
                for _, tbl in getgc(true) do
                    if type(tbl) ~= "table" then
                        continue;
                    end;
        
                    local current_rpm = rawget(tbl, "RPM");
                    if current_rpm then
                        if not gun_mods.old_firerates[tbl] then
                            gun_mods.old_firerates[tbl] = current_rpm
                        end
        
                        if value then
                            tbl.RPM = gun_mods.old_firerates[tbl] * Library.Flags["RPM Boost"];
                        else
                            tbl.RPM = gun_mods.old_firerates[tbl];
                        end;
                    end;
                end;
            end;
            ui.sections['rage_weaponmods']:Toggle({Name = "RPM", Flag = "Enable RPM", Default = false, Callback = fast_fire_callback });
            ui.sections['rage_weaponmods']:Slider({ Name = "RPM Boost", Flag = "RPM Boost", Minimum = 1, Maximum = 3, Default = 0, Decimals = 0.1, Ending = '%', Callback = fast_fire_callback });
            --ui.sections['rage_weaponmods']:Toggle({Name = 'Always Headshot', Flag = 'Always Headshot'})
            ui.sections['rage_weaponmods']:Toggle({Name = 'Instant Hit', Flag = 'Instant Hit', Callback = function(state)
                if (state) then
                    for _, tbl in getgc(true) do
                        if type(tbl) ~= "table" then
                            continue
                        end

                        local bullet_table = rawget(tbl, "Bullet")
                        if bullet_table and type(bullet_table) == "table" then
                            if not gun_mods.old_bullet_speeds[bullet_table] then
                                gun_mods.old_bullet_speeds[bullet_table] = bullet_table.Speed
                            end
                            bullet_table.Speed = 10000
                        end
                    end
                else
                    for tbl, speed_value in gun_mods.old_bullet_speeds do
                        tbl["Speed"] = speed_value
                    end
                end
            end});
            --ui.sections['rage_weaponmods']:Toggle({Name = 'Instant Aim', Flag = 'Instant Aim'})
            --ui.sections['rage_weaponmods']:Toggle({Name = 'Instant Equip', Flag = 'Instant Equip'})
        end;
    end;
    --
    do -- visuals
        ui.window:Seperator({Name = 'Visuals'});
        ui.tabs['visuals'] = ui.window:Page({
            Name = 'Player',
            Icon = 'http://www.roblox.com/asset/?id=6031075931'
        });
        do
            ui.sections['esp'] = ui.tabs['visuals']:Section({Name = 'ESP', Side = 'Left', Size = 417});
            ui.sections['esp']:Toggle({Name = 'Names', Flag = 'Enable Names'});         
            ui.sections['esp']:Toggle({Name = 'Boxes', Flag = 'Enable Boxes'});
            ui.sections['esp']:Toggle({Name = 'Distance', Flag = 'Enable Distance'});
            ui.sections['esp']:Toggle({Name = 'Weapon', Flag = 'Enable Weapon'});
            ui.sections['esp']:Toggle({Name = 'Healthbar', Flag = 'Enable Healthbar'});
            ui.sections['esp']:Toggle({Name = 'Healthtext', Flag = 'Enable Healthtext'});
            ui.sections['esp']:Toggle({Name = 'Viewangle', Flag = 'Enable Viewangle'});
            ui.sections['esp']:Slider({Name = 'Viewangle Length', Flag = 'Viewangle Length', Default = 5, Minimum = 1, Maximum = 15, Decimals = 0.1, Ending = ''});
            ui.sections['esp']:Toggle({Name = 'Skeleton', Flag = 'Enable Skeletons'});
            ui.sections['esp']:Slider({Name = 'Skeleton Thickness', Flag = 'Skeleton Thickness', Default = 1, Minimum = 1, Maximum = 2, Decimals = 0.1, Ending = ''});
            ui.sections['esp']:Toggle({Name = 'Chams', Flag = 'Enable Chams'});
            ui.sections['esp']:Slider({Name = 'Chams Opacity', Flag = 'Chams Opacity', Default = 50, Minimum = 0, Maximum = 100, Decimals = 1, Ending = '%'});
            ui.sections['esp']:List({Name = 'Chams', Flag = 'Chams Visible Check', Options = { "Visible Only", "Always Visible" }});
        end;
        do
            ui.sections['esp_colors'] = ui.tabs['visuals']:Section({Name = 'ESP Colors', Side = 'Right', Size = 227});
            ui.sections['esp_colors']:Colorpicker({Name = 'Names Color', Flag = 'Names Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Boxes Color', Flag = 'Boxes Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Distance Color', Flag = 'Distance Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Weapon Color', Flag = 'Weapon Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Viewangle Color', Flag = 'Viewangle Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Skeletons Color', Flag = 'Skeletons Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Chams Color', Flag = 'Chams Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['esp_colors']:Colorpicker({Name = 'Highlight Color', Flag = 'Highlight Accent', Default = Color3.fromRGB(255, 0, 0)});
        end;
        do
            ui.sections['esp settings'] = ui.tabs['visuals']:Section({Name = 'ESP Settings', Side = 'Right', Size = 187});
            ui.sections['esp settings']:Toggle({Name = 'Highlight Target', Flag = 'Highlight ESP'});
            ui.sections['esp settings']:Toggle({Name = 'Team Check', Flag = 'Enable TeamCheck'});
            ui.sections['esp settings']:Toggle({Name = 'Display Name', Default = true, Flag = 'Display Name'});
            ui.sections['esp settings']:Toggle({Name = 'Outline Skeletons/ViewAngle', Flag = 'Outline Skeletons/ViewAngle'});
            ui.sections['esp settings']:Slider({Name = 'Max ESP Distance', Flag = 'Max ESP Distance', Default = 500, Minimum = 100, Maximum = 2500, Decimals = 1, Ending = 's'});
        end;
        --
        ui.tabs['world'] = ui.window:Page({
            Name = 'World',
            Icon = 'http://www.roblox.com/asset/?id=6034684930'
        });
        do
            ui.sections['world esp'] = ui.tabs['world']:Section({Name = 'ESP', Side = 'Left', Size = 227});
            ui.sections['world esp']:Toggle({Name = 'Enable', Flag = 'Enable World ESP'});
            ui.sections['world esp']:Slider({Name = 'Max ESP Distance', Flag = 'World ESP Max Distance', Default = 500, Minimum = 100, Maximum = 2500, Decimals = 1, Ending = 's'});
        end;
        do
            local bases_folder = {
                workspace.Bases.Loners:FindFirstChild("External Wooden Wall") or nil,
                workspace.Bases.Loners:FindFirstChild("External Wooden Gate") or nil,
                workspace.Bases.Loners:FindFirstChild("External Stone Wall") or nil,
                workspace.Bases.Loners:FindFirstChild("External Stone Gate") or nil,
            };
            
            for _, v in pairs(workspace.Bases:GetChildren()) do
                if v:IsA("Folder") and v.Name == "Base" then
                    for _, sub in ipairs({"Doorway", "Floor", "Triangle Floor", "Foundation", "Triangle Foundation", "Wall", "Wall Frame", "Window"}) do
                        local sub_folder = v:FindFirstChild(sub);
                        if sub_folder then table.insert(bases_folder, sub_folder) end;
                    end;
                end;
            end;
            
            getgenv().xray_toggle = false;
            getgenv().xray_enabled = false;
            getgenv().xray_opacity = 0.5;
            
            local function upd_xray(state)
                if not getgenv().xray_toggle then return end
                for _, v in pairs(bases_folder) do
                    for _, obj in ipairs(v:GetDescendants()) do
                        if obj:IsA("MeshPart") then obj.Transparency = state and getgenv().xray_opacity or 0 end;
                    end;
                end;
            end;
            
            ui.sections['xray'] = ui.tabs['world']:Section({Name = 'Xray', Side = 'Left', Size = 133})
            ui.sections['xray']:Toggle({Name = 'Enable', Flag = 'Enable Xray', Callback = function(state) getgenv().xray_toggle = state end})
            ui.sections['xray']:Keybind({Flag = 'Xray Keybind', Name = 'Xray Keybind', Default = Enum.KeyCode.T, Mode = 'Toggle', Callback = function() 
                if getgenv().xray_toggle then 
                    getgenv().xray_enabled = not getgenv().xray_enabled 
                    upd_xray(getgenv().xray_enabled) 
                end 
            end});
            ui.sections['xray']:Slider({Name = 'Opacity', Flag = 'Xray Opacity', Default = 50, Minimum = 0, Maximum = 100, Decimals = 1, Ending = '%', Callback = function(state) 
                getgenv().xray_opacity = state / 100 
                if getgenv().xray_toggle and getgenv().xray_enabled then upd_xray(true) end 
            end});
        end;
        do
            ui.sections['world customisation'] = ui.tabs['world']:Section({Name = 'World Customisation', Side = 'Right', Size = 287});
            ui.sections['world customisation']:Toggle({Name = 'No Grass', Callback = function(state) sethiddenproperty(Workspace:FindFirstChildOfClass("Terrain"), "Decoration", not state) end});
            ui.sections['world customisation']:Toggle({Name = 'No Fog', Flag = 'Enable No Fog'});
            ui.sections['world customisation']:Toggle({ Name = 'Fullbright', Flag = 'Enable Fullbright', Callback = function(state) lighting["GlobalShadows"] = state; end});       
            ui.sections['world customisation']:Toggle({Name = 'Ambient', Flag = 'Enable Ambient'});
            ui.sections['world customisation']:Colorpicker({Name = 'Outdoor Ambient Color', Flag = 'Outdoor Ambient Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['world customisation']:Colorpicker({Name = 'Ambient Color', Flag = 'Ambient Accent', Default = Color3.fromRGB(255, 255, 255)});
            ui.sections['world customisation']:List({Name = 'Skybox', Flag = 'Skyboxes', Options = skys, Callback = function(state)
                if (skyboxes[state]) then
                    sky.SkyboxBk = "rbxassetid://" .. skyboxes[state][1];
                    sky.SkyboxDn = "rbxassetid://" .. skyboxes[state][2];
                    sky.SkyboxFt = "rbxassetid://" .. skyboxes[state][3];
                    sky.SkyboxLf = "rbxassetid://" .. skyboxes[state][4];
                    sky.SkyboxRt = "rbxassetid://" .. skyboxes[state][5];
                    sky.SkyboxUp = "rbxassetid://" .. skyboxes[state][6];
                end;
            end});
        end;
        do
            ui.tabs['local'] = ui.window:Page({
                Name = 'Local',
                Icon = 'http://www.roblox.com/asset/?id=6034684930'
            });
            do
                ui.sections['viewmodel'] = ui.tabs['local']:Section({Name = 'Viewmodel', Side = 'Right', Size = 137});
                ui.sections['viewmodel']:Toggle({ Name = 'Local Chams', Flag = 'Local Chams' })
                ui.sections['viewmodel']:Slider({ Name = 'Local Chams Opacity', Flag = 'Local Chams Opacity', Default = 50, Minimum = 0, Maximum = 100, Decimals = 1, Ending = '%'})
                ui.sections['viewmodel']:Colorpicker({ Name = 'Local Chams Color', Flag = 'Local Chams Accent', Default = Color3.fromRGB(255, 255, 255)})
            end;
            do
                ui.sections['traps'] = ui.tabs['local']:Section({Name = 'Misc', Side = 'Left', Size = 117});
                local stored_parts = {DamagePart = {}, TouchCollision = {}, Collision = {}};
                local function new_toggle(name, partName)
                    ui.sections['traps']:Toggle({
                        Name = name,
                        Flag = name,
                        Default = false,
                        Callback = function(state)
                            if (state) then
                                for _, v in workspace:GetDescendants() do
                                    if v:IsA("BasePart") and v.Name == partName then
                                        stored_parts[partName][v] = v.Parent;
                                        v.Parent = cloneref(game:GetService("CoreGui"));
                                        v.Destroying:Connect(function() stored_parts[partName][v] = nil end);
                                    end;
                                end;
                            else
                                for part, old_parent in pairs(stored_parts[partName]) do
                                    part.Parent = old_parent;
                                end;
                                table.clear(stored_parts[partName]);
                            end;
                        end;
                    });
                end;
                
                new_toggle("No Spike Damage", "DamagePart");
                new_toggle("No Trap Damage", "TouchCollision");
                new_toggle("No Fire Damage", "Collision");
                
                workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("BasePart") then
                        for partName, flag in pairs({
                            DamagePart = Flags["No Spike Damage"],
                            TouchCollision = Flags["No Trap Damage"],
                            Collision = Flags["No Fire Damage"]
                        }) do
                            if descendant.Name == partName and flag then
                                stored_parts[partName][descendant] = descendant.Parent
                                descendant.Parent = cloneref(game:GetService("CoreGui"))
                                descendant.Destroying:Connect(function() stored_parts[partName][descendant] = nil end)
                            end;
                        end;
                    end;
                end);                             
            end;
        end;
    end;
    --
    do -- settings
        ui.window:Seperator({Name = 'Settings'})
        ui.tabs['settings'] = ui.window:Page({
            Name = 'Settings',
            Icon = 'http://www.roblox.com/asset/?id=6031280882'
        });
        Library:Configs(ui.tabs['settings']);
    end;
end;
-- 
do -- fov circle
    local FieldOfView = player_esp.functions.create_drawing("ScreenGui", { Parent = cloneref(gethui()), IgnoreGuiInset = true });
    local Frame = player_esp.functions.create_drawing("Frame", { Visible = false, BackgroundTransparency = 1, Size = UDim2.new(0, Flags["FOV Radius"] * 2, 0, Flags["FOV Radius"] * 2), Position = UDim2.new(0, 0, 0, 0), AnchorPoint = Vector2.new(0.5, 0.5), Parent = FieldOfView, ZIndex = 2 });
    local UICorner = player_esp.functions.create_drawing("UICorner", { CornerRadius = UDim.new(1, 0), Parent = Frame });
    local Stroke = player_esp.functions.create_drawing("UIStroke", { Color = Color3.new(1, 1, 1), Thickness = 2, Transparency = 0, Parent = Frame })
    -- returns
    fov_circle.FieldOfView = FieldOfView;
    fov_circle.Frame = Frame;
    fov_circle.Stroke = Stroke;
end;
--
do -- snaplines
    local snaplines = player_esp.functions.create_drawing("ScreenGui", { Parent = cloneref(gethui()), IgnoreGuiInset = true });
    local line = player_esp.functions.create_drawing("Frame", { BackgroundTransparency = 0, AnchorPoint = Vector2.new(0.5, 0.5), BorderSizePixel = 0, ZIndex = 2, Parent = snaplines });
    -- returns
    snap_lines.snaplines = snaplines;
    snap_lines.line = line;
end;
--
do -- other functions
    local old_setting = settings_table.GetSetting;
    do -- funcs
        settings_table.GetSetting = function(cat, set, ...)
            if (set == "Field Of View") then
                if Flags["FOV"] and not (Flags["Zoom"] and Flags["Zoom Keybind"]) then
                    return Flags["FOV Ammount"];
                elseif Flags["Zoom"] and Flags["Zoom Keybind"] then
                    return Flags["Zoom Ammount"];
                end;
            end;
            return old_setting(cat, set, ...);
        end;
    end;
end;
-- hooks
LPH_NO_VIRTUALIZE(function() 
    local bullet_stuff, raycast_stuff do 
        for i,v in pairs(getgc(true)) do 
            if typeof(v) == "table" and rawget(v,"Raycast") then 
                raycast_stuff = v;
            elseif typeof(v) == "table" and rawget(v,"CreateProjectile") then 
                bullet_stuff = v;
            end;
        end;

        local rc; rc = hookfunction(raycast_stuff.Raycast,function(...) 
            local args = {...};
            local calling = getcallingscript();

            if getgenv().silent and getgenv().silent_key and math.random(1, 100) <= getgenv().silent_hitchance and calling and calling.Name == "ViewmodelController" then 
                local entry, closest_part = player_esp.functions.get_player();
            
                if closest_part and entry and closest_part and entry ~= local_player then 
                    args[3] = (closest_part.Position - args[2]).Unit * 2500
                end;
            end;

            return rc(unpack(args));
        end);
    end;
end)()
--
do -- loops
    game:GetService("RunService").RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
        if (Flags["Enable Aimbot"] or getgenv().silent) then
            entry, closest_part = player_esp.functions.get_player();
        end;

        do -- update target
            if closest_part and (closest_part ~= target_paradox.target.part) then
                target_paradox.target.part = closest_part;
                target_paradox.target.entry = entry;
                target_paradox.target.distance = (closest_part.Position - camera.CFrame.Position).Magnitude;
            end;
        end;

        highlight_player = target_paradox.target.entry; -- highlight

        do -- local chams
            for _, model in ipairs(folder:GetChildren()) do
                if model:IsA("Model") then
                    local highlight = model:FindFirstChildOfClass("Highlight")
                    
                    if Flags["Local Chams"] then
                        if not highlight then
                            highlight = Instance.new("Highlight")
                            highlight.Parent = model
                        end
                        highlight.FillColor = Flags["Local Chams Accent"]
                        highlight.OutlineColor = Flags["Local Chams Accent"]
                        highlight.OutlineTransparency = Flags["Local Chams Opacity"] / 100
                        highlight.FillTransparency = Flags["Local Chams Opacity"] / 100
                        highlight.Enabled = true
                    elseif highlight then
                        highlight.Enabled = false
                    end
                end
            end
        end
        -- 
        do -- plr mods
            -- always sprint
            if (Flags["Always Sprint"] and (uis:IsKeyDown(Enum.KeyCode.W) or uis:IsKeyDown(Enum.KeyCode.A) or uis:IsKeyDown(Enum.KeyCode.S) or uis:IsKeyDown(Enum.KeyCode.D))) then
                local plr_model = local_char;
                if (plr_model and plr_model:FindFirstChild("HumanoidRootPart")) then
                    local root = plr_model:FindFirstChild("HumanoidRootPart");
                    if (root) then
                        local dir, look = Vector3.new(), camera.CFrame.LookVector;
        
                        for k, v in pairs({
                            [Enum.KeyCode.W] = Vector3.new(look.X, 0, look.Z); 
                            [Enum.KeyCode.A] = Vector3.new(look.Z, 0, -look.X); 
                            [Enum.KeyCode.S] = Vector3.new(-look.X, 0, -look.Z); 
                            [Enum.KeyCode.D] = Vector3.new(-look.Z, 0, look.X)
                        }) do
                            if uis:IsKeyDown(k) then 
                                dir += v;
                            end;
                        end;
        
                        if (dir.Magnitude > 0) then 
                            root.Velocity = dir.Unit * 27 + Vector3.new(0, root.Velocity.Y, 0);
                        end;
                    end;
                end;
            end;
            -- spiderclimb
            if (Flags["Spiderclimb"] and Flags["Spiderclimb Keybind"]) then
                local plr_model = local_char or local_player.CharacterAdded:Wait();
                
                if (plr_model and plr_model:FindFirstChild("HumanoidRootPart")) then
                    local hrp = plr_model.HumanoidRootPart;
                    local climb_speed = Flags["Spiderclimb Speed"];

                    local current_velocity = hrp.AssemblyLinearVelocity;
                    local vertical_velocity = Vector3.new(0, climb_speed, 0);
        
                    hrp.CFrame = hrp.CFrame * CFrame.new(0, climb_speed * 0.1, 0);
                    hrp.AssemblyLinearVelocity = Vector3.new(current_velocity.X, vertical_velocity.Y, current_velocity.Z);
                end;
            end;                 
        end;
        --
        do -- lighting
            if (Flags["Enable Fullbright"]) then
                if lighting.ClockTime ~= (Flags["Enable Fullbright"] and 12 or lighting_cache.ClockTime) then
                    lighting.ClockTime = Flags["Enable Fullbright"] and 12 or lighting_cache.ClockTime;
                end;
            else
                lighting.ClockTime = lighting_cache.ClockTime;
            end;
            -- 
            if Flags["Enable No Fog"] then
                lighting.FogEnd = 100000;
                local atmosphere = lighting:FindFirstChild("Atmosphere")
                if (atmosphere) then
                    atmosphere.Density, atmosphere.Offset, atmosphere.Glare, atmosphere.Haze = 0, 0, 0, 0;
                end;
            else
                lighting.FogEnd = lighting_cache.FogEnd
                local atmosphere = lighting:FindFirstChild("Atmosphere");
                if (atmosphere) then
                    atmosphere.Density, atmosphere.Offset, atmosphere.Glare, atmosphere.Haze = lighting_cache.Density, lighting_cache.Offset, lighting_cache.Glare, lighting_cache.Haze;
                end;
            end;            
            -- 
            if (Flags["Enable Ambient"]) then
                if lighting.OutdoorAmbient ~= (Flags["Enable Ambient"] and Flags["Outdoor Ambient Accent"] or lighting_cache.OutdoorAmbient) then
                    lighting.OutdoorAmbient = Flags["Enable Ambient"] and Flags["Outdoor Ambient Accent"] or lighting_cache.OutdoorAmbient
                end;
                if lighting.Ambient ~= (Flags["Enable Ambient"] and Flags["Ambient Accent"] or lighting_cache.Ambient) then
                    lighting.Ambient = Flags["Enable Ambient"] and Flags["Ambient Accent"] or lighting_cache.Ambient
                end;
            else
                lighting.Ambient = lighting_cache.Ambient;
                lighting.OutdoorAmbient = lighting_cache.OutdoorAmbient;
            end;
        end;
        -- 
        do -- fov circle
            if (Flags["Enable FOV"]) then
                fov_circle.Frame.Visible = true;
                fov_circle.Stroke.Color = Flags["FOV Accent"];

                local size = Flags["FOV Radius"] * 2 / math.tan(math.rad(camera.FieldOfView / 2));
                fov_circle.Frame.Size = UDim2.new(0, size, 0, size);
                fov_circle.Frame.Position = UDim2.new(0, uis:GetMouseLocation().X, 0, uis:GetMouseLocation().Y);
            else
                fov_circle.Frame.Visible = false;
            end;
        end;
        --
        do -- snaplines
            if (Flags["Enable Aimbot"] or getgenv().silent) and Flags["Enable Snaplines"] then
                local line = snap_lines.line;
                if (closest_part) then
                    local screen_pos = camera:WorldToViewportPoint(closest_part.Position);
                    local from = Vector2.new(screen_pos.X, screen_pos.Y);
                    local to = uis:GetMouseLocation();
                    local offset = to - from;
                    local middle = from + offset * 0.5;
                    local distance = offset.Magnitude;

                    local line = snap_lines.line;
                    line.Position = UDim2.new(0, middle.X, 0, middle.Y);
                    line.Rotation = math.deg(math.atan2(offset.Y, offset.X));
                    line.Size = UDim2.new(0, math.floor(distance + 0.5), 0, 1);
                    line.BackgroundColor3 = Flags["Snaplines Accent"];
                    line.Visible = true;
                else
                    line.Visible = false;
                end
            else
                snap_lines.line.Visible = false;
            end;
        end;
        --
        do -- aimbot
            if (target_paradox.target.entry and target_paradox.target.part and target_paradox.target.entry ~= local_player) then
                if (Flags["Enable Aimbot"]) and Flags["Aimbot Keybind"] then
                    local enemy_pos = target_paradox.target.part.Position;
                    camera.CFrame = Flags["Aimbot Speed"] ~= 1 and camera.CFrame:Lerp(CFrame.lookAt(camera.CFrame.Position, enemy_pos), Flags["Aimbot Speed"]) or CFrame.lookAt(camera.CFrame.Position, enemy_pos);
                end;
            end;
        end;
        --
    end));
end;
